# java-master

## 布隆过滤器

布隆过滤器是由Bloom在1970年提出的一种多哈希函数映射的快速查找算法。通常应用在一些快速需要判断某个元素是否属于集合，但是并不严格要求100%正确的场合。

布隆过滤器存在的重要意义，可以用一个实例来说明。假设要写一个网络爬虫，由于网络间的链接错综复杂，爬虫在网络间的爬取很可能会形成“环”。为了避免形成“环”，就需要指导爬虫已经访问过哪些URL。给定一个URL，怎样能知晓这个是否已经被爬虫访问过呢？一般有如下几种解决方案：

- 将访问过的URL保存到数据库
- 用HashSet将访问过的URL保存起来，那只需接近O（1）的代价就可以查到一个URL是否被访问过
- URL经过MD5或SHA-1等单向哈希后在保存到HashSet或数据库
- BitMap方法，建立一个BitSet，将每个URL经过一个哈希函数映射到某一位

以上方法在数据量较小的情况下都能提供完美解决方案，但是当数据量变得非常庞大时问题就出现了。

方案一的缺点：数据量变得非常庞大后关系型数据库查询的效率会变得很低，而且每个URL就启动一次数据库查询有点小题大作；

方案二的缺点：太消耗内存。随着URL的增多，占用的内存会越来越多，就算只有一亿个URL，每个URL只算50个字符，就需要5GB内存；

方案三的缺点：由于字符串经过MD5处理后的信息摘要长度只有128比特，SHA-1处理后也只有160比特，因此方法三比方法二省了好几倍的内存；

方法四的内存消耗是相对较少的，但缺点是单一哈希函数发生冲突的概率太高。

实质上上面的算法忽略了一个重要的隐含条件：允许小概率的出错，不一定100%准确，也就是说少量URL实际上没有网络爬虫访问，而将它们判别错误为已访问的代价是很小的——少爬取几个网页。

###布隆过滤器算法

其实上面方法四的思想已经很接近布隆过滤器了，但是方法四的致命缺点是冲突概率高，为了降低冲突发生的概率，布隆过滤器使用了多哈希函数，而不是一个。其算法如下：

    创建一个m位BitSet，先将所有位初始化为0，然后选择k个不同的哈希函数。第i个哈希函数对字符串str哈希的结果即为h（i, str），且h（i, str）的取值范围为[0, m - 1]
    
（1）加入字符串过程

下面是每个字符串处理的过程，首先将字符串str记录到BitSet中的过程：对于字符串str，分别计算h（1，str），h（2，str），……，h（k，str）。然后将BitSet的第h（1，str），h（2，str），……，h（k，str）位设置为1，这样就将字符串str映射到BitSet中的k个二进制位了。
![布隆过滤器插入字符串](src/main/resources/images/bloom-insert.jpg)

（2）检查字符串是否存在的过程

具体过程为：对于字符串str，分别计算h（1，str），h（2，str）…… h（k，str）。然后检查BitSet的第h（1，str）、h（2，str）…… h（k，str）位是否为1，若其中任何一位不为1则可以判定str一定没有被记录过。若全部位都是1，则“认为”字符串str存在。

若一个字符串对应的Bit不全为1，则可以肯定该字符串一定没有被Bloom Filter记录过。（这是显然的，因为字符串被记录过，其对应的二进制位肯定全部被设为1了）；

但是若一个字符串对应的Bit全为1，实际上是不能100%的肯定该字符串被Bloom Filter记录过的。（因为有可能该字符串的所有位都刚好是被其他字符串所对应）这种将该字符串划分错的情况，称为false positive 。

（3）删除字符串过程

字符串加入就不能被删除了，因为删除会影响到其他字符串。实在需要删除字符串的可以使用计数型布隆过滤器（CBF），这是一种基本布隆过滤器的辩题，CBF将基本布隆过滤器的每一个比特改为一个计数器，这样就可以实现删除字符串的功能了。

    布隆过滤器与单哈希函数Bit-Map的区别在于：布隆过滤器使用了k个哈希函数，每个字符串跟k个比特对应，从而降低了冲突发生的概率。
    
#### 布隆过滤器参数选择

（1）哈希函数选择

哈希函数的选择对性能的影响是很大的，一个好的哈希函数要能近似等概率的将字符串映射到各个比特位。选择k个不同的哈希函数比较麻烦，一种简单的方法就是选择一个哈希函数，然后传入k个不同的参数。

（2）比特位数组大小选择

哈希函数个数k、位数组大小m、加入的字符串数量n的关系可以参考[设置说明](http://pages.cs.wisc.edu/~cao/papers/summary-cache/node8.html)，该文献证明了给定的m、n好，当`k=ln(2)*m/n`时出错的概率是最小的。

## BIO与NIO、AIO的区别

IO的方式通常分为几种，同步阻塞的BIO、同步非阻塞的NIO、异步非阻塞的AIO。

- BIO

在JDK1.4出来之前，我们建立网络连接的时候采用BIO模式，需要先在服务端启动一个ServerSocket，然后在客户端启动Socket来对服务端进行通信，默认情况下服务端需要对每个请求建立一堆线程等待请求，而客户端发送请求后，先咨询服务器是否有线程响应，如果没有则会一直等待或者遭到拒绝请求，如果有的话，客户端线程会等待请求结束后才继续执行。

- NIO

NIO本身是**基于事件**驱动思想设计的，其主要思想解决的是BIO的大并发问题：在使用同步I/O的网络应用中，如果要同时处理多个客户端其你去，或是在客户端同时与多个服务器进行通信，就必须使用多线程来处理。也就是说，将每一个客户端请求分配给一个县城来单独处理。这样做虽然能够达到我们的要求，但同时又会带来另外一个问题。由于每创建一个县城，就要为这个线程分配一定的内存空间（也叫工作存储器），而且操作系统本身对线程的总数有限制。如果客户端的请求过多，服务端程序可能会因为不堪重负而拒绝客户端的请求，甚至服务器可能因此会因此而瘫痪。

NIO基于Reactor模型，当Socket有流可读或可写入socket时，操作系统会相应的通知应用程序处理，应用再将流读取到缓冲区或写入操作系统。也就是说，这个时候，已经㐊一个连接对应一个处理线程了，而是有效的请求，对应一个县城，当连接没有数据时，是没有工作线程来处理的。

BIO与NIO一个比较重要的不同，是我们使用BIO的时候往往引入多线程，每个连接一个单独的线程；而NIO则是单线程或者只使用少量的多线程，每个连接共用一个线程。

![NIO和BIO关系图](src/main/resources/images/nio-bio.png)

NIO最重要的地方是当一个连接创建后，不需要对应一个线程，这个连接会被注册到多路复用器上面，所以所有的连接只需要一个线程就可以搞定，当这个线程中的多路复用器进行轮询的时候，发现连接上有请求的话，才开启一个线程进行处理，也就是一个请求一个线程模式。

在NIO的处理方式中，当一个请求来的话，开启线程进行处理，可能要等待后端应用的资源（JDBC连接等），其实这个线程就被阻塞了，当并发上来的话，还是会有BIO一样的问题。

HTTP/1.1出现后，有了Http长连接，这样除了超时和指明特定关闭http header外，这个链接是一直打开的状态，这样在NIO处理中可以进一步的优化，在后端资源中可以实现资源池或者队列，当请求来的话，开启的线程把请求和请求数据传送给后端资源池或者队列里面就返回，并且在全局的地方保持住这个线程，这样前面的线程还是可以去接受其他的请求，而后端的应用的处理只需要执行队列里面的就可以了，这样请求处理和后端应用时异步的。当后端处理完，到全局地方得到现场，产生响应，这样就实现了异步处理。

- AIO

与NIO不同，当进行读写处理时，只需直接调用API的read和write方法即可。这两种方法均为异步，对于读操作而言，当有流可读取时，操作系统会将可读的流传入read方法的缓冲区，并通知应用程序；对于写操作而言，当操作系统将write方法传递的流写入完毕时，操作系统主动通知应用程序。即可以理解为，read和write方法都是异步的，完成后会主动调用回调函数。在JDK1.7中，这部分内容被称作NIO.2，主要是在java.nio.channels包下增加了下面四个异步通道：

（1）AsynchronousSocketChannel

（2）AsynchronousServerSocketChannel

（3）AsynchronousFileChannel

（4）AsynchronousDatagramChannel

其中的read和write方法，会返回一个带有回调函数的对象，当执行完读取/写入操作后，直接调用回调函数。

#### Java对BIO、NIO和AIO的支持

**BIO**：同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善；

**NIO**：同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理；

**AIO**：异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。

#### BIO、NIO和AIO适用场景分析

**BIO**：适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解；

**NIO**：适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持；

**AIO**：使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。

## Reactor模型和Proactor模型

在高性能的IO设计中，有两个比较著名的模式，即**Reactor模式**和**Proactor模式**，其中Reactor模式用于同步I/O，Proactor用于异步I/O。同步和异步的区分：同步指的是用户进程触发I/O操作并等待或者轮询的去查看IO操作是否就绪，而异步是指用户进程触发I/O操作后便开始做自己的事情，而当IO操作已经完成的时候会得到IO完成就绪的通知。阻塞和非阻塞：是根据IO操作的就绪状态来采取的不同方式，其实就是一种读取和写入操作函数的实现方式，阻塞方式下读取或者写入函数将一直等待，而非阻塞方式下，读取或者写入函数会立即返回一个状态值。

**同步阻塞IO**：在此种方式下，用户进程在发起一个IO操作以后，必须等待IO操作的完成，只有当真正的完成了IO操作以后，用户进程才能继续运行，Java传统的IO模型就是这种方式；

**同步非阻塞IO**：在这种方式下，用户进程发起一个IO操作以后便可返回做其他事情，但是用户进程需要时不时的询问IO操作是否就绪，这就要求用户进程不停的去询问，从而引入不必要的CPU资源浪费，其中目前Java的NIO就属于同步非阻塞IO；

**异步阻塞IO**：此种方式下是指应用发起一个IO操作以后，不等待内核IO操作的完成，等内核完成IO操作以后会通知应用程序，这其实是同步和异步最关键的区别，同步必须等待或者主动的去询问IO是否完成，name为什么说是阻塞的呢？因为此时是通过select系统调用来完成的，而select函数本身的实现方式是阻塞的，而采用select函数有个好处就是它可以同时监听多个文件句柄，从而提高系统的并发性；

**异步非阻塞IO**：在这种模式下，用户进程只需要发起一个IO操作然后立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知，此时用户进程只需要对数据进行处理就好了，不需要进行实际的IO读写操作，因为真正的IO读取或者写入操作已经由内核完成了。目前Java中还没有支持此种IO模型。
